# 18 GIL线程全局锁

# 线程全局锁(Global Interpreter Lock),即Python为了保证线程安全而采取的独立线程运行的限制,说白了就是一个核只能在同一时间运行一个线程.对于io密集型任务，python的多线程起到作用，但对于cpu密集型任务，python的多线程几乎占不到任何优势，还有可能因为争夺资源而变慢。

# 见Python 最难的问题

# 解决办法就是多进程和下面的协程(协程也只是单CPU,但是能减小切换代价提升性能).

# 19 协程

# 知乎被问到了,呵呵哒,跪了

# 简单点说协程是进程和线程的升级版,进程和线程都面临着内核态和用户态的切换问题而耗费许多切换时间,而协程就是用户自己控制切换的时机,不再需要陷入系统的内核态.

# Python里最常见的yield就是协程的思想!可以查看第九个问题.

# 20 闭包

# 闭包(closure)是函数式编程的重要的语法结构。闭包也是一种组织代码的结构，它同样提高了代码的可重复使用性。

# 当一个内嵌函数引用其外部作作用域的变量,我们就会得到一个闭包. 总结一下,创建一个闭包必须满足以下几点:

# 必须有一个内嵌函数
# 内嵌函数必须引用外部函数中的变量
# 外部函数的返回值必须是内嵌函数
# 感觉闭包还是有难度的,几句话是说不明白的,还是查查相关资料.

# 重点是函数运行后并不会被撤销,就像16题的instance字典一样,当函数运行完后,instance并不被销毁,而是继续留在内存空间里.这个功能类似类里的类变量,只不过迁移到了函数上.

# 闭包就像个空心球一样,你知道外面和里面,但你不知道中间是什么样.

# 21 lambda函数

# 其实就是一个匿名函数,为什么叫lambda?因为和后面的函数式编程有关.

# 推荐: 知乎

# 22 Python函数式编程

# 这个需要适当的了解一下吧,毕竟函数式编程在Python中也做了引用.

# 推荐: 酷壳

# python中函数式编程支持:

# filter 函数的功能相当于过滤器。调用一个布尔函数bool_func来迭代遍历每个seq中的元素；返回一个使bool_seq返回值为true的元素的序列。

# a = [1,2,3,4,5,6,7]

# b = filter(lambda x: x > 5, a)

# print b

# [6,7]

# map函数是对一个序列的每个项依次执行函数，下面是对一个序列每个项都乘以2：

#  a = map(lambda x:x*2,[1,2,3])

#  list(a)

# [2, 4, 6]

# reduce函数是对一个序列的每个项迭代调用函数，下面是求3的阶乘：

# reduce(lambda x,y:x*y,range(1,4))

# 6